require "ecc_generic.jinc"

export fn ecc_double(#transient reg u64 r p) {
    #msf reg u64 ms;

    #secret stack u64[NLIMBS] x1 y1 z1;  
    #secret stack u64[NLIMBS] x2 y2 z2;
    #public stack u64 sr sp sq;

    ms = #init_msf();

    x1, y1, z1 = __load_projective_point(p); 

    x2, y2, z2 = _ecc_double(x1, y1, z1, x2, y2, z2);

    __store_projective_point(r, x2, y2, z2);
}

export fn ecc_add(#transient reg u64 r p q) {
    #msf reg u64 ms;

    #secret stack u64[NLIMBS] x1 y1 z1;  
    #secret stack u64[NLIMBS] x2 y2 z2;
    #secret stack u64[NLIMBS] x3 y3 z3;
    #public stack u64 sr sp sq;

    ms = #init_msf();

    x1, y2, z1 = __load_projective_point(p); 
    x2, y2, z2 = __load_projective_point(q);

    x3, y3, z3 = _ecc_add(x1, y2, z1, x2, y2, z2, x3, y3, z3);

    __store_projective_point(r, x3, y3, z3);
}

export fn ecc_scalar_mul(#transient reg u64 q p k) {
    #msf reg u64 ms;

    #public stack u64[NLIMBS] scalar; 
    #secret stack u64[NLIMBS] qx qy qz;
    #secret stack u64[NLIMBS] px py pz; // R1

    #public stack u64 sp sk sq;

    ms = #init_msf();

    #declassify scalar = __bn_load(k);
    
    px, py, pz = __load_projective_point(p); 

    qx, qy, qz, ms = _ecc_scalar_mul(scalar, qx, qy, qz, px, py, pz, ms);

    // q = sq; // retrieve q from the stack
    // q = #protect(q, ms);

    __store_projective_point(q, qx, qy, qz);
}